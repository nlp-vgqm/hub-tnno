
Dict = {"经常": 0.1,
        "经": 0.05,
        "有": 0.1,
        "常": 0.001,
        "有意见": 0.1,
        "歧": 0.001,
        "意见": 0.2,
        "分歧": 0.2,
        "见": 0.05,
        "意": 0.05,
        "见分歧": 0.05,
        "分": 0.1}

# 待切分文本
sentence = "经常有意见分歧"


# 实现全切分函数，输出根据字典能够切分出的所有的切分方式
# 动态规划
def all_cut(sentence, Dict):
    n = len(sentence)
    # dp[i] 存储所有能够切分到位置i的切分方式
    dp = [[] for _ in range(n + 1)]
    dp[0] = [[]]  # 空句子的基础情况

    # 第一步：构建动态规划表，记录所有可能的切分位置
    for i in range(n + 1):
        if not dp[i]:  # 如果位置i不可达，跳过
            continue
        for j in range(i + 1, n + 1):
            word = sentence[i:j]
            if word in Dict:
                # 记录从位置i到位置j可以通过word到达
                for seg_list in dp[i]:
                    dp[j].append(seg_list + [word])

    # 第二步：从dp[n]中获取所有完整的切分路径
    return dp[n]


# 测试
target = all_cut(sentence, Dict)

# 打印结果
for i, segmentation in enumerate(target, 1):
    print(f"{i:2d}. {segmentation}")

# 目标输出;顺序不重要
target = [
    ['经常', '有意见', '分歧'],
    ['经常', '有意见', '分', '歧'],
    ['经常', '有', '意见', '分歧'],
    ['经常', '有', '意见', '分', '歧'],
    ['经常', '有', '意', '见分歧'],
    ['经常', '有', '意', '见', '分歧'],
    ['经常', '有', '意', '见', '分', '歧'],
    ['经', '常', '有意见', '分歧'],
    ['经', '常', '有意见', '分', '歧'],
    ['经', '常', '有', '意见', '分歧'],
    ['经', '常', '有', '意见', '分', '歧'],
    ['经', '常', '有', '意', '见分歧'],
    ['经', '常', '有', '意', '见', '分歧'],
    ['经', '常', '有', '意', '见', '分', '歧']
]
